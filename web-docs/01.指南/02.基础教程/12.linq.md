---
title: "Linq"
date: "2022-01-30T10:11:12.000Z"
permalink: "/pages/base/linq/"
---
# 基本语法

    select 
        tableAlias.*|[tableAlias.]field[ columnAlias]
        [,tableAlias.field2[ columnAlias2][,…]]
    from expr[,…] tableAlias
    [[left ]join expr tableAlias2 on condition]
    [where condition]
    [group by tableAlias.field[,...]]
    [having condition]
    [order by tableAlias.field[asc|desc][,tableAlias.field[asc|desc]]]
    [limit expr [offset expr]]


# 执行步骤

 * 先从from子句创建虚拟表VT1
 * 处理join，创建虚拟表VT2，筛选符合条件condition的行加入到虚拟表VT2中
 * 处理where 将符合condition的行加入虚拟表VT1中
 * 处理group by 对虚拟表VT1、VT2进行分组操作，将符合having condition的值加入虚拟表VT3中
 * 处理select 从VT3中选择指定的列，加入虚拟表VT4中
 * 处理order by 对虚拟表VT4进行排序
 * 处理limit


# select子句

select t.name,sum(t.score) score,t.*


> select 中带有聚合函数的，应该有group by语句，否则不会进行聚合处理


# from子句

-- 以下三种方式均可（别名是必须的）
from [{name: 'Gitee'},[name:'Github']] t
from results t
from {name:'Gitee'} t


> from 跟着的必须是List或者Map


# join子句

-- 以下三种方式均可（别名是必须的）
[left] join [{name: 'Gitee'},[name:'Github']] t1 on t1.name = t.name
[left] join results t1 on 1 = 1
[left] join {name:'Gitee'} t1 on t1.name = 'Gitee' and 1=1



# where子句

-- or 等价于|| and 等价于 && 可以混合使用。
where t.name = 'Gitee' or t.name = 'Github' and 1=1 && 2=2



# group by子句

-- 分组操作
group by t.name, t1.xxx



# having 子句

-- 筛选分组后的数量大于 1 的
having count(t.name) > 1



# order by子句

-- asc可以不写，默认是asc
order by t.name desc,t.xxx 



# limit 子句

limit 1 -- 固定取第一项，返回值会是对象，而非List
-- 跳过(page - 1) * pageSize条取pageSize条
limit pageSize offset (page - 1) * pageSize
-- 取前pageSize条
limit pageSize
